import * as core from '@actions/core';
import { Octokit } from '@octokit/rest';
import {
  CompatibilityReport,
  CompatibilityResult,
  GITHUB_MARKERS,
  STATUS_EMOJIS,
  BaselineStatus,
} from '@greenlightci/shared';

/**
 * Get the Octokit instance for GitHub API
 */
export function getOctokit(token: string): Octokit {
  return new Octokit({ auth: token });
}

/**
 * Get PR diff content
 */
export async function getPRDiff(
  octokit: Octokit,
  owner: string,
  repo: string,
  pullNumber: number
): Promise<string> {
  try {
    const { data } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: pullNumber,
      mediaType: {
        format: 'diff',
      },
    });

    return data as unknown as string;
  } catch (error) {
    core.error(`Failed to fetch PR diff: ${error}`);
    throw error;
  }
}

/**
 * Format compatibility report as markdown comment
 */
export function formatComment(report: CompatibilityReport): string {
  const { results, score, blockingCount, warningCount, totalFeatures } = report;

  let comment = `${GITHUB_MARKERS.COMMENT_HEADER}\n\n`;
  comment += `# ${GITHUB_MARKERS.COMMENT_TITLE}\n\n`;

  // Overall score
  const scoreEmoji = score >= 90 ? 'üü¢' : score >= 70 ? 'üü°' : 'üî¥';
  comment += `**Compatibility Score:** ${scoreEmoji} ${score}/100\n\n`;

  // Summary
  comment += `### Summary\n`;
  comment += `- **Features Detected:** ${totalFeatures}\n`;
  comment += `- **Blocking Issues:** ${blockingCount > 0 ? `‚ùå ${blockingCount}` : '‚úÖ 0'}\n`;
  comment += `- **Warnings:** ${warningCount > 0 ? `‚ö†Ô∏è ${warningCount}` : '‚úÖ 0'}\n\n`;

  if (results.length === 0) {
    comment += `‚úÖ No web features detected in this PR that require compatibility checking.\n`;
    return comment;
  }

  // Group results by severity
  const blocking = results.filter((r: CompatibilityResult) => r.blocking);
  const warnings = results.filter(
    (r: CompatibilityResult) => r.severity === 'warning' && !r.blocking
  );
  const info = results.filter(
    (r: CompatibilityResult) => r.severity === 'info'
  );

  // Blocking issues
  if (blocking.length > 0) {
    comment += `### ‚ùå Blocking Issues\n\n`;
    comment += `The following features need attention before merging:\n\n`;

    for (const result of blocking) {
      comment += formatFeatureResult(result);
    }
  }

  // Warnings
  if (warnings.length > 0) {
    comment += `### ‚ö†Ô∏è Warnings\n\n`;
    comment += `These features are newly available and may need polyfills:\n\n`;

    for (const result of warnings) {
      comment += formatFeatureResult(result);
    }
  }

  // Info
  if (info.length > 0) {
    comment += `### ‚ÑπÔ∏è Detected Features\n\n`;
    comment += `<details>\n<summary>Click to expand (${info.length} features)</summary>\n\n`;

    for (const result of info) {
      comment += formatFeatureResult(result);
    }

    comment += `</details>\n\n`;
  }

  comment += `\n---\n`;
  comment += `ü§ñ *Generated by [GreenLightCI](https://github.com/your-org/greenlightci)*\n`;

  return comment;
}

/**
 * Format individual feature result
 */
function formatFeatureResult(result: CompatibilityResult): string {
  const { feature, filePath, line } = result;
  const statusEmoji = getStatusEmoji(feature.status);

  let output = `#### ${statusEmoji} \`${feature.name}\`\n\n`;
  output += `- **Status:** ${feature.status}`;

  if (feature.baselineYear) {
    output += ` (Baseline ${feature.baselineYear})`;
  }
  output += `\n`;

  output += `- **Location:** \`${filePath}\``;
  if (line) {
    output += `:${line}`;
  }
  output += `\n`;

  // Browser support
  if (Object.keys(feature.support).length > 0) {
    output += `- **Browser Support:** `;
    const supportList: string[] = [];
    if (feature.support.chrome)
      supportList.push(`Chrome ${feature.support.chrome}`);
    if (feature.support.edge) supportList.push(`Edge ${feature.support.edge}`);
    if (feature.support.firefox)
      supportList.push(`Firefox ${feature.support.firefox}`);
    if (feature.support.safari)
      supportList.push(`Safari ${feature.support.safari}`);
    output += supportList.join(', ') + `\n`;
  }

  // Links
  if (feature.mdnUrl) {
    output += `- üìñ [MDN Documentation](${feature.mdnUrl})\n`;
  }

  output += `\n`;
  return output;
}

/**
 * Get emoji for baseline status
 */
function getStatusEmoji(status: BaselineStatus): string {
  switch (status) {
    case BaselineStatus.WidelyAvailable:
      return STATUS_EMOJIS.WIDELY_AVAILABLE;
    case BaselineStatus.NewlyAvailable:
      return STATUS_EMOJIS.NEWLY_AVAILABLE;
    case BaselineStatus.Limited:
      return STATUS_EMOJIS.LIMITED;
    case BaselineStatus.NotBaseline:
      return STATUS_EMOJIS.NOT_BASELINE;
    default:
      return STATUS_EMOJIS.UNKNOWN;
  }
}

/**
 * Post or update comment on PR
 */
export async function postComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  pullNumber: number,
  body: string
): Promise<void> {
  try {
    // Check if we already have a comment
    const { data: comments } = await octokit.rest.issues.listComments({
      owner,
      repo,
      issue_number: pullNumber,
    });

    const existingComment = comments.find((comment) =>
      comment.body?.includes(GITHUB_MARKERS.COMMENT_HEADER)
    );

    if (existingComment) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: existingComment.id,
        body,
      });
      core.info('Updated existing baseline compatibility comment');
    } else {
      // Create new comment
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: pullNumber,
        body,
      });
      core.info('Created new baseline compatibility comment');
    }
  } catch (error) {
    core.error(`Failed to post comment: ${error}`);
    throw error;
  }
}

/**
 * Set PR status check
 */
export async function setStatus(
  octokit: Octokit,
  owner: string,
  repo: string,
  sha: string,
  state: 'success' | 'failure' | 'pending',
  description: string
): Promise<void> {
  try {
    await octokit.rest.repos.createCommitStatus({
      owner,
      repo,
      sha,
      state,
      context: 'Baseline Compatibility',
      description,
      target_url: `https://github.com/${owner}/${repo}/actions`,
    });
  } catch (error) {
    core.warning(`Failed to set status: ${error}`);
  }
}
